<DOCTYPE HTML>
    <html lang="en">
        <head>
            <meta charset="UTF-8">
        </head>
        <body style="margin: 0%;">
            <canvas id="gameCanvas" style="left: 0%; width: 100%; image-rendering: pixelated, crisp-edges; position:fixed;"></canvas>
            <script>
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 640;
                canvas.height = 360;
                ctx.antiAliasing = false;
                let mapWidth = 20;
                let mapHeight = 20;
                let blockSize = 10;
                let plr = {x: (mapWidth*blockSize)*0.5+mapWidth/2+5, y: (mapHeight*blockSize)*0.5+mapHeight/2+5, d: 0, vx: 0, vy: 0, radius: 1, moveSpeed: 0.25, moveDirction: 0};
                let FOV = Math.PI/2;
                let QUALITY = 320;
                let keysDown = {};
                let returnQuality = 0.1;
                const WALLHEIGHT = 2000;
                let viewDistance = 1500;
                let mouseDX = 0;
                let mouseDY = 0;
                let mouseX, mouseY = 0;
                let mousetimeoutFrames = 0;
                let then = Date.now();
                let deltaTime = 0.1;
                let dv = 320/Math.tan(FOV/2);
                let started = false;
                const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                grad.addColorStop(0, 'rgb(128, 128, 128)');
                grad.addColorStop(0.5, "black");
                grad.addColorStop(1, 'rgb(128, 96, 32)');
                class Entity {
                    constructor(image, sound, speed, range, x, y, d) {
                        this.img = new Image(10, 10);
                        this.img.src = image;
                        this.sound = new Audio(sound);
                        this.sound.loop = true;
                        this.speed = speed;
                        this.range = range;
                        this.x = x;
                        this.y = y;
                        this.d = d;
                    }
                }
                let map = [
                    1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
                    1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1,
                    1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1,
                    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0,
                    1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0,
                    0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0,
                    1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
                    0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                    1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                    1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
                    1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1,
                    1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1,
                    1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1,
                    0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,
                    1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
                    1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                    1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
                    1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                ];
                let loadedEntities = [];
                //level1.onload = function(){
                    //console.log('loaded! ', level1);
                    window.addEventListener("keydown", function(input){keysDown[input.key.toLowerCase()] = true;});
                    window.addEventListener("keyup", function(input){keysDown[input.key.toLowerCase()] = false;});
                    window.addEventListener("mousedown", function(event){
                        canvas.requestPointerLock();
                        if(!started){
                            started = true;
                            loadedEntities = [
                                new Entity('assets/fsh.jpg', undefined, 0.4, 30, plr.x-10, 200, 1),
                            ]
                            requestAnimationFrame(step);
                            console.log(loadedEntities);
                        }
                    });
                    window.addEventListener("mousemove", function(event){mouseDX = event.movementX; mouseDY = event.movementY; mouseY += mouseDY});
                //}
    
                function getTileAt(x, y){
                    return map[Math.floor((x%(mapWidth*blockSize))/blockSize)+(Math.floor((y%(mapHeight*blockSize))/blockSize)*mapHeight)];
                }
    
                function checkCollision(x, y, size, q){
                    let collided = false;
                    for(let i = 0; i < loadedEntities.length; i++){
                        if(Math.abs(x-loadedEntities[i].x) <= 2 && Math.abs(y-loadedEntities[i].y) <= 2){
                            collided = true;
                        }
                    }
                    return getTileAt(x, y) != 0 || getTileAt(x+size, y+size) != 0 || getTileAt(x-size, y+size) != 0 || getTileAt(x-size, y-size) != 0 || getTileAt(x-size, y-size) != 0 || collided
                }
    
                function renderMinimap(){
                    let x = 0;
                    let y = 0;
                    for(i = 0; i < mapWidth*mapHeight; i++){
                        if(map[x+(y*mapWidth)] == 1){
                            ctx.fillStyle = 'white';
                        }else{
                            ctx.fillStyle = 'black';
                        }
                        ctx.fillRect(x*blockSize, y*blockSize, blockSize, blockSize);
                        x++;
                        if(x>=mapWidth){
                            x=0;
                            y++;
                        }
                
                    }
                    ctx.fillStyle = 'green';
                    ctx.fillRect(plr.x-(plr.radius/2), plr.y-(plr.radius/2), plr.radius+1, plr.radius+1);
                    ctx.fillStyle = 'red';
                    for(let i = 0; i < loadedEntities.length; i++){
                        ctx.fillRect(loadedEntities[i].x-1, loadedEntities[i].y-1, 2, 2);
                    }
                }
    
                function render(){
                    //ctx.drawImage(level1, canvas.width, canvas.height);
                    ctx.strokeStyle = 'cyan';
                    for(i = 0; i < QUALITY; i++){
                        let r = castRay(plr.x, plr.y, plr.d-Math.atan((i*(canvas.width/QUALITY)-canvas.width/2)/dv), 0.1);
                        ctx.fillStyle = 'rgb(' + viewDistance/r.dist + ', ' + viewDistance/r.dist + ', 0)';
                        r.dist *= Math.cos(Math.atan((i*(canvas.width/QUALITY)-canvas.width/2)/dv));
                        ctx.fillRect(Math.floor(i*(canvas.width/QUALITY)), Math.floor((canvas.height/2-(0))-(WALLHEIGHT/r.dist)/2), Math.ceil(canvas.width/QUALITY), Math.ceil(WALLHEIGHT/r.dist));
                    }
                    renderMinimap();
                }
    
                function moveEntities(){
                    let moving = false;
                    plr.d -= mouseDX/100;
                    plr.moveDirction = plr.d;
                    if(keysDown['w']){
                        moving = true;
                    }
                    if(keysDown['s']){
                        plr.moveDirction -= Math.PI;
                        moving = true;
                    }
                    if(keysDown['d']){
                        if(keysDown['w']){
                            plr.moveDirction -= Math.PI/4;
                        }else if(keysDown['s']){
                            plr.moveDirction += Math.PI/4;
                        }else{
                            plr.moveDirction -= Math.PI/2;
                        }
                        moving = true;
                    }
                    if(keysDown['a']){
                        if(keysDown['w']){
                            plr.moveDirction += Math.PI/4;
                        }else if(keysDown['s']){
                            plr.moveDirction -= Math.PI/4;
                        }else{
                            plr.moveDirction += Math.PI/2;
                        }
                        moving = true;
                    }
                    if(keysDown['shift']){
                        plr.moveSpeed = 0.5;
                    }else{
                        plr.moveSpeed = 0.25;
                    }
                    if(keysDown['insert']){
                        console.log(loadedEntities);
                    }
                    if(moving){
                        plr.x += Math.sin(plr.moveDirction)*plr.moveSpeed;
                        if(checkCollision(plr.x, plr.y, plr.radius) != 0){
                            plr.x -= Math.sin(plr.moveDirction)*plr.moveSpeed;
                        }
                        plr.y += Math.cos(plr.moveDirction)*plr.moveSpeed;
                        if(checkCollision(plr.x, plr.y, plr.radius) != 0){
                            plr.y -= Math.cos(plr.moveDirction)*plr.moveSpeed;
                        }
                    }
                    //move entities
                    for(let i = 0; i < loadedEntities.length; i++){
                        loadedEntities[i].d = Math.atan2(plr.x - loadedEntities[i].x, plr.y - loadedEntities[i].y);
                        loadedEntities[i].x += Math.sin(loadedEntities[i].d)*loadedEntities[i].speed;
                        loadedEntities[i].y += Math.cos(loadedEntities[i].d)*loadedEntities[i].speed;
                    }
                }
    
                function castRay(X, Y, D, quality){
                    let ray = {hit: {x: X, y: Y}, dist: 0};
                    let collided = false;
                    while (getTileAt(ray.hit.x, ray.hit.y) == 0 && getTileAt(ray.hit.x-quality, ray.hit.y) == 0 && ray.dist < 255 && !collided){
                        ray.hit.x += Math.sin(D)*quality;
                        ray.hit.y += Math.cos(D)*quality;
                        ray.dist += quality;
                        for(let i = 0; i < loadedEntities.length; i++){
                            if(Math.abs(ray.hit.x-loadedEntities[i].x) <= 2 && Math.abs(ray.hit.y-loadedEntities[i].y) <= 2){
                                collided = true;
                                break;
                            }
                        }
                    }
                    while (getTileAt(ray.hit.x, ray.hit.y) != 0 && !collided){
                        ray.hit.x -= Math.sin(D)*returnQuality;
                        ray.hit.y -= Math.cos(D)*returnQuality;
                        ray.dist -= returnQuality;
                    }
                    return ray
                }
    
                function step(){
                    deltaTime = Date.now() - then;
                    then = Date.now();
                    console.log(deltaTime);
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    //ctx.drawImage(level1, 0, 0);
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    moveEntities();
                    render();
                    if(mouseDX != 0){
                        mouseDX = 0;
                    }
                    if(mouseDY != 0){
                        mouseDY = 0;
                    }
                    requestAnimationFrame(step);
                }
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = "200px Arial";
                ctx.fillStyle = 'white';
                ctx.fillText('Click to begin', 0, 200, canvas.width)
            </script>
        </body>
    </html>