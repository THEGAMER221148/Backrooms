<DOCTYPE HTML>
    <html lang="en">
        <head>
            <meta charset="UTF-8">
        </head>
        <body style="margin: 0%;">
            <canvas id="gameCanvas" style="left: 0%; width: 100%; image-rendering: pixelated, crisp-edges; position:fixed;"></canvas>
            <script>
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 640;
                canvas.height = 360;
                ctx.antiAliasing = false;
                let mapWidth = 20;
                let mapHeight = 20;
                let blockSize = 10;
                let plr = {x: (mapWidth*blockSize)*0.5+mapWidth/2+5, y: (mapHeight*blockSize)*0.5+mapHeight/2+5, d: 0, vx: 0, vy: 0, radius: 1, moveSpeed: 0, moveDirction: 0};
                let FOV = Math.PI/2;
                let QUALITY = 200;
                let keysDown = {};
                let returnQuality = 0.1;
                const WALLHEIGHT = 2000;
                let viewDistance = 1500;
                let mouseDX = 0;
                let mouseDY = 0;
                let mouseX, mouseY = 0;
                let mousetimeoutFrames = 0;
                let then = Date.now();
                let deltaTime = 0.1;
                let dv = 320/Math.tan(FOV/2);
                let started = false;
                let raycastDistances = [];
                let raycastXs = [];
                let raycastTypes = [];
                const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                grad.addColorStop(0, 'rgb(128, 128, 128)');
                grad.addColorStop(0.5, "black");
                grad.addColorStop(1, 'rgb(128, 96, 32)');
                class Entity {
                    constructor(image, sound, speed, range, x, y, d) {
                        this.img = new Image(50, 50);
                        this.img.src = image;
                        this.sound = new Audio(sound);
                        this.sound.loop = true;
                        this.speed = speed;
                        this.range = range;
                        this.x = x;
                        this.y = y;
                        this.d = d;
                    }
                }
                let map = [
                    1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
                    1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1,
                    1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1,
                    0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0,
                    1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0,
                    0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0,
                    1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
                    0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
                    1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
                    1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
                    1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1,
                    1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1,
                    1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1,
                    0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,
                    1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1,
                    1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                    1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
                    1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                ];
                let loadedEntities = [];
                //level1.onload = function(){
                    //console.log('loaded! ', level1);
                    window.addEventListener("keydown", function(input){keysDown[input.key.toLowerCase()] = true;});
                    window.addEventListener("keyup", function(input){keysDown[input.key.toLowerCase()] = false;});
                    window.addEventListener("mousedown", function(event){
                        canvas.requestPointerLock();
                        if(!started){
                            started = true;
                            loadedEntities = [
                                new Entity('assets/Chatticussabluddington.webp', undefined, 0.3, 30, plr.x-10, 200, 1),
                            ]
                            requestAnimationFrame(step);
                            console.log(loadedEntities);
                        }
                    });
                    window.addEventListener("mousemove", function(event){mouseDX = event.movementX; mouseDY = event.movementY; mouseY += mouseDY});
                //}
                
                function getDistanceFrom(x1, y1, x2, y2){
                    return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
                }

                function getTileAt(x, y){
                    return map[Math.floor((x%(mapWidth*blockSize))/blockSize)+(Math.floor((y%(mapHeight*blockSize))/blockSize)*mapHeight)];
                }
    
                function checkCollision(x, y, size, q){
                    let collided = false;
                    return getTileAt(x, y) != 0 || getTileAt(x+size, y+size) != 0 || getTileAt(x-size, y+size) != 0 || getTileAt(x-size, y-size) != 0 || getTileAt(x-size, y-size) != 0 || collided
                }
    
                function renderMinimap(){
                    let x = 0;
                    let y = 0;
                    for(i = 0; i < mapWidth*mapHeight; i++){
                        if(map[x+(y*mapWidth)] == 1){
                            ctx.fillStyle = 'white';
                        }else{
                            ctx.fillStyle = 'black';
                        }
                        ctx.fillRect(x*blockSize, y*blockSize, blockSize, blockSize);
                        x++;
                        if(x>=mapWidth){
                            x=0;
                            y++;
                        }
                
                    }
                    ctx.fillStyle = 'green';
                    ctx.fillRect(plr.x-(plr.radius/2), plr.y-(plr.radius/2), plr.radius+1, plr.radius+1);
                    ctx.fillStyle = 'red';
                    for(let i = 0; i < loadedEntities.length; i++){
                        ctx.fillRect(loadedEntities[i].x-1, loadedEntities[i].y-1, 2, 2);
                    }
                }
    
                function render(){
                    //get distances
                    raycastDistances = [viewDistance+blockSize+1];
                    raycastTypes = [undefined];
                    raycastXs = [undefined];
                    let drawIDX = 1;
                    let insertX = 0;
                    for(i = 0; i < QUALITY; i++){
                        let r = castRay(plr.x, plr.y, plr.d-Math.atan((i*(canvas.width/QUALITY)-canvas.width/2)/dv), 0.1);
                        r.dist *= Math.cos(Math.atan((i*(canvas.width/QUALITY)-canvas.width/2)/dv));
                        drawIDX = 1;
                        while(raycastDistances[drawIDX-1] < r.dist){
                            drawIDX --;
                        }
                        while(raycastDistances[drawIDX] > r.dist){
                            drawIDX ++;
                        }
                        raycastTypes.splice(drawIDX, 0, 1);
                        raycastXs.splice(drawIDX, 0, insertX);
                        raycastDistances.splice(drawIDX, 0, r.dist);
                        insertX += (canvas.width/QUALITY);
                    }
                    //render walls and entities
                    for(i = 1; i < raycastXs.length; i++){
                        if(raycastTypes[i] == 1){
                            ctx.fillStyle = 'rgb(' + viewDistance/raycastDistances[i+1] + ', ' + viewDistance/raycastDistances[i+1] + ', 0)';
                            ctx.fillRect((raycastXs[i]), Math.floor((canvas.height/2-(0))-(WALLHEIGHT/raycastDistances[i+1])/2), Math.ceil(canvas.width/QUALITY), Math.ceil(WALLHEIGHT/raycastDistances[i+1]));
                            for(j = 0; j < loadedEntities.length; j++){
                                let entity = loadedEntities[j];
                                if(raycastDistances[i+1]-getDistanceFrom(plr.x, plr.y, entity.x, entity.y) < 0.1){
                                    let distanceToScreen = ((entity.x - plr.x) * Math.sin(plr.d)) + ((entity.y - plr.y) * Math.cos(plr.d));
                                    let size = 10 * (dv / distanceToScreen);
                                    size = size/100 * getDistanceFrom(0, 0, entity.img.width, entity.img.height);
                                    console.log((((entity.x - plr.x) * Math.cos(plr.d)) - ((entity.y - plr.y) * Math.sin(plr.d)))/ distanceToScreen)
                                    ctx.drawImage(entity.img, (canvas.width / 2) - (((entity.x - plr.x) * Math.cos(plr.d)) - ((entity.y - plr.y) * Math.sin(plr.d))) * (dv / distanceToScreen) - (size / 2), canvas.height / 2 - size / 2, size, size);
                                }
                            }
                        }
                    }
                    renderMinimap();
                }
    
                function moveEntities(){
                    let moving = false;
                    plr.d -= mouseDX/100;
                    plr.d = Math.floor(plr.d/(FOV/QUALITY))*(FOV/QUALITY);
                    plr.moveDirction = plr.d;
                    if(keysDown['w']){
                        moving = true;
                    }
                    if(keysDown['s']){
                        plr.moveDirction -= Math.PI;
                        moving = true;
                    }
                    if(keysDown['d']){
                        if(keysDown['w']){
                            plr.moveDirction -= Math.PI/4;
                        }else if(keysDown['s']){
                            plr.moveDirction += Math.PI/4;
                        }else{
                            plr.moveDirction -= Math.PI/2;
                        }
                        moving = true;
                    }
                    if(keysDown['a']){
                        if(keysDown['w']){
                            plr.moveDirction += Math.PI/4;
                        }else if(keysDown['s']){
                            plr.moveDirction -= Math.PI/4;
                        }else{
                            plr.moveDirction += Math.PI/2;
                        }
                        moving = true;
                    }
                    if(keysDown['shift']){
                        plr.moveSpeed = 0.5;
                    }else{
                        plr.moveSpeed = 0.4;
                    }
                    if(keysDown['insert']){
                        console.log(raycastDistances, raycastXs);
                    }
                    if(moving){
                        plr.vx += Math.sin(plr.moveDirction)*plr.moveSpeed;
                        plr.vy += Math.cos(plr.moveDirction)*plr.moveSpeed;
                        plr.vx *= plr.moveSpeed;
                        plr.vy *= plr.moveSpeed;
                        plr.x += plr.vx*(deltaTime/17);
                        if(checkCollision(plr.x, plr.y, plr.radius) != 0){
                            plr.x -= plr.vx;
                            plr.vx = 0;
                        }
                        plr.y += plr.vy*(deltaTime/17);
                        if(checkCollision(plr.x, plr.y, plr.radius) != 0){
                            plr.y -= plr.vy;
                            plr.vy = 0;
                        }
                    }else{
                        plr.vx = 0;
                        plr.vy = 0;
                    }
                    //move entities
                    for(let i = 0; i < loadedEntities.length; i++){
                        loadedEntities[i].d = Math.atan2(plr.x - loadedEntities[i].x, plr.y - loadedEntities[i].y);
                        loadedEntities[i].x += Math.sin(loadedEntities[i].d)*(loadedEntities[i].speed*(deltaTime/17));
                        loadedEntities[i].y += Math.cos(loadedEntities[i].d)*(loadedEntities[i].speed*(deltaTime/17));
                    }
                }
    
                function castRay(X, Y, D, quality){
                    let ray = {hit: {x: X, y: Y}, dist: 0};
                    let collided = false;
                    while (getTileAt(ray.hit.x, ray.hit.y) == 0 && getTileAt(ray.hit.x-quality, ray.hit.y) == 0 && ray.dist < 255 && !collided){
                        ray.hit.x += Math.sin(D)*quality;
                        ray.hit.y += Math.cos(D)*quality;
                        ray.dist += quality;
                    }
                    while (getTileAt(ray.hit.x, ray.hit.y) != 0 && !collided){
                        ray.hit.x -= Math.sin(D)*returnQuality;
                        ray.hit.y -= Math.cos(D)*returnQuality;
                        ray.dist -= returnQuality;
                    }
                    return ray
                }
    
                function step(){
                    deltaTime = Date.now() - then;
                    then = Date.now();
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    //ctx.drawImage(level1, 0, 0);
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    moveEntities();
                    render();
                    if(mouseDX != 0){
                        mouseDX = 0;
                    }
                    if(mouseDY != 0){
                        mouseDY = 0;
                    }
                    requestAnimationFrame(step);
                }
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = "200px Arial";
                ctx.fillStyle = 'white';
                ctx.fillText('Click to begin', 0, 200, canvas.width)
            </script>
        </body>
    </html>